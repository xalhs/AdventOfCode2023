# Advent of Code 2023
These are my scripts for the puzzles at https://adventofcode.com/2023 I will be uploading all days that I solve with a short commentary on thought process/description. All the puzzles (so far) have been solved without looking up any hint related to the event. Note that my naming process for the input texts is input + the date. So for the first day it was input1.txt, the second day input2.txt... etc.

## Day 1
There is not much to say about part 1, you just iterate through each line forward or backwards and pick the first number you see then concatentate them and sum all those for each line. For part 2, it's a bit trickier since there are numbers spelled out. A first idea is to replace the spelling of the number with the number itself (for example replace "two" with "2") which could work but there are issues. The main issue is when two spelled out numbers share a letter (like "eightwo") here if you replace the "eight" it will be "8wo" but then you lost the "two". The safest way to do it is to replace each spelled out number with the number but also the first and last letter of the spelled out number. For example "one" is replaced by "o1e", "two" by "t2o", "three" by "t3e"... etc. No spelled out number combinations share more than one letter so this is enough.

## Day 4
Part 1 is just comparing lists and finding matches. For each match you multiply the value of the card by 2 (or set it to 1 if it was 0), then you add all the values of the cards. Part 2 is much more confusing now instead of increasing the value of the cards, matches increase the number of future cards you get. The way I solved it was by using a list of the multiplicities of each card that I had and increased that number according to the instructions. So if card 6 had multiplicity 5 (i.e. I had 5 total copies of card 6) and card 6 had 7 matches then I added 5 to the multiplicity of cards 7 8 9 10 11 12 13.

## Day 5 
Day 5 was one of my favorites and one of the most difficult. Part 1 was a bit of a hurdle writing all the mappings. The key is figuring out that each mapping (for the range that it operates on) is just adding the difference of the beginning of the image (where it takes you) of the map with the beginning of the domain (where it came from). Part 2 was much more difficult, in principle it was the same logic as part one, however, the number of seeds now was huge since instead of individual seeds they were now ranges of seeds.  Computing them 1 by 1 was not an option. The way I solved it was that instead of operating with the maps on the seeds individually, I operated on the ranges. So I proccessed each range through the maps, splitting it accordingly at the map borders and it turned out pretty nice. Code was pretty tedious to write but it runs almost insantly so I am very happy with the result.

## Day 7 
Day 7 was a fun little exercise. The main theme is evaluating hands in a game similar to poker. The evaluation is based primarily on type (five of a kind, four of a kind... etc.) and secondarily on the strongest card in hand (from left to right). To solve this I implemented an evaluation function. It evaluates each hand in base 13 (since there are 13 different cards). The last card in hand counts for its value times $13^0$ the second to last card counts for its value times $13^1$... up until the first card which counts for its value times $13^4$. Finally the evaluation checks the type of the hand and adds an evaluation based on the type times $13^5$. This way all different hands have a different value. Then it is just a matter of calculating the order of the hands which is done by sorting the dictionary of values and then adding the bets according to the exercise. Part 2 wasn't much harder. Here the card "J" can substitute for any other card basically. The way I did it was seeing that the most optimal hand will always be if the "J"s all substitute to the same card and then I just ran the evaluation function while substituting "J" with every card then picked the highest. And then I solved it as in part 1.

## Day 8
Day 8 was fairly straightforward. The key idea for part 1 is using a dictionary to easily move between locations then once you reach the location "ZZZ" you are done and you check the number of steps. Part 2 has a small trick into it. You basically have to do the same procedure but for multiple locations simultaneously and you only finish when all of them finish. You can't use the direct way because the number of steps is too large. To solve this you must see that all movements between locations are periodic for each initial point and you can calculate the period for each individual starting location using the algorithm from part 1. Then after finding all periods the result we need is just the least common multiple of all the periods we found.

## Day 11
For part 1, I just did as instructed and expanded the universe, then I just made a list of all the positions of galaxies and used the taxicab geometry to find their pairwise relative distance. For part 2 you could in theory do the same thing as part one but with a bigger expansion coefficient, however, this is not computationally efficient (or realistically feasible) so you have to go about it in a smarter way. The way I did it was to just mark the positions of the galaxies on the unexpanded universe then check how many rows and columns are to be expanded between them and add that to their relative distance. 

## Day 14
Day 14 was interesting, the first part was pretty easy, we just have to check for each "." whether there is an "O" or a "#" somewhere below it, if it's an "O" then we swap the two. Then after doing that for all entries we just calculate the load based on the position of the "O"s. Part 2 was a bit more interesting, it involves tilting the pattern in other directions than North. To do that I simply made a function to rotate clockwise the whole pattern and then rotated North as before. The interesting part comes from the fact that we need to do a whole cycle of rotations a billion times. Clearly that is not computationally efficient so we have to find a smarter way. My guess was that after a few cycles the pattern would reach a stable position which would not change with more cycles. What actually happens is that the pattern enters a loop of positions that alternate periodically. To solve it I just ran the cycle enough times to reach this periodicity and then I calculated the period (which was 18, this was done by hand but it wouldn't be hard to add the period calculation into the algorithm). Finally I only evaluated the positions $i$ such that $i \equiv 1000000000 (\mathrm{mod} 18)$. (Since the position repeats every 18 cycles, then the pattern at $i$ would be the same as the pattern at 1 billion considering the period is 18). Then I just calculated the load for that pattern. 

## Day 15
Day 15 was pretty easy, the first part is just applying some hash algorithm. The second part was confusing to read but it's pretty clear from the description that we are supposed to use dictionaries which make the puzzle pretty easy.

## Day 19
Day 19 was very interesting. Part 1 was just translating the commands of the input into commands in code. To solve it I used a nested function which terminated when the configuration was accepted or rejected. Part 2 is where it gets interesting. Here we had to figure out the configuration space of the parameters that are accepted. To do this I used a similar function to part 1 but instead of a single configuration it uses ranges of configurations as input. When it hits an instruction (such as an inequality), the range splits and the function is called again with the new range. If finally some range gets accepted then the size of the configuration space is added to the sum.