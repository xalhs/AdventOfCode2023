# Advent of Code 2023
These are my scripts for the puzzles at https://adventofcode.com/2023 I will be uploading all days that I solve with a short commentary on thought process/description. All the puzzles (so far) have been solved without looking up any hint related to the event. Note that my naming process for the input texts is input + the date. So for the first day it was input1.txt, the second day input2.txt... etc.

## Day 7 
Day 7 was a fun little exercise. The main theme is evaluating hands in a game similar to poker. The evaluation is based primarily on type (five of a kind, four of a kind... etc.) and secondarily on the strongest card in hand (from left to right). To solve this I implemented an evaluation function. It evaluates each hand in base 13 (since there are 13 different cards). The last card in hand counts for its value times $13^0$ the second to last card counts for its value times $13^1$... up until the first card which counts for its value times $13^4$. Finally the evaluation checks the type of the hand and adds an evaluation based on the type times $13^5$. This way all different hands have a different value. Then it is just a matter of calculating the order of the hands which is done by sorting the dictionary of values and then adding the bets according to the exercise. Part 2 wasn't much harder. Here the card "J" can substitute for any other card basically. The way I did it was seeing that the most optimal hand will always be if the "J"s all substitute to the same card and then I just ran the evaluation function while substituting "J" with every card then picked the highest. And then I solved it as in part 1.

## Day 11
For part 1, I just did as instructed and expanded the universe, then I just made a list of all the positions of galaxies and used the taxicab geometry to find their pairwise relative distance. For part 2 you could in theory do the same thing as part one but with a bigger expansion coefficient, however, this is not computationally efficient (or realistically feasible) so you have to go about it in a smarter way. The way I did it was to just mark the positions of the galaxies on the unexpanded universe then check how many rows and columns are to be expanded between them and add that to their relative distance. 

## Day 14
Day 14 was interesting, the first part was pretty easy, we just have to check for each "." whether there is an "O" or a "#" somewhere below it, if it's an "O" then we swap the two. Then after doing that for all entries we just calculate the load based on the position of the "O"s. Part 2 was a bit more interesting, it involves tilting the pattern in other directions than North. To do that I simply made a function to rotate clockwise the whole pattern and then rotated North as before. The interesting part comes from the fact that we need to do a whole cycle of rotations a billion times. Clearly that is not computationally efficient so we have to find a smarter way. My guess was that after a few cycles the pattern would reach a stable position which would not change with more cycles. What actually happens is that the pattern enters a loop of positions that alternate periodically. To solve it I just ran the cycle enough times to reach this periodicity and then I calculated the period (which was 18, this was done by hand but it wouldn't be hard to add the period calculation into the algorithm). Finally I only evaluated the positions $i$ such that $i \equiv 1000000000 (\mathrm{mod} 18)$. (Since the position repeats every 18 cycles, then the pattern at $i$ would be the same as the pattern at 1 billion considering the period is 18). Then I just calculated the load for that pattern. 

## Day 15
Day 15 was pretty easy, the first part is just applying some hash algorithm. The second part was confusing to read but it's pretty clear from the description that we are supposed to use dictionaries which make the puzzle pretty easy.
